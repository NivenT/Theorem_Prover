(defun slice (lst start &optional (end (length lst)))
	(cond	((null lst) lst)
			((= end 0) nil)
			((< end 0) (slice lst start (+ end (length lst))))
			((< start 0) (slice lst (+ start (length lst)) end))
			((< end start) nil)
			((= start 0) (cons (car lst) (slice (cdr lst) 0 (1- end))))
			(t (slice (cdr lst) (1- start) (1- end)))))
(defun all-of (test lst &key (key #'identity))
	(loop for i in lst do
		(unless (funcall test (funcall key i))
			(return-from all-of nil)))
	t)
(defun myunion (&rest lsts)
	(cond	((null lsts) nil)
			((= (length lsts) 1) (car lsts))
			((= (length lsts) 2) (union (car lsts) (cadr lsts) :test #'eq-expr))
			(t (union (car lsts) (apply #'myunion (cdr lsts)) :test #'eq-expr))))
(defun flatten (lst)
	(cond 	((null lst) nil)
			((listp lst) (append (flatten (car lst)) (flatten (cdr lst))))
			(t (list lst))))
(defun mappend (func lst)
	(apply #'append (mapcar func lst)))
			
			
(defun variablep (x)
	"Returns whether or not x is a variable (symbol of form ?x)"
	(and (symbolp x) (equal (char (symbol-name x) 0) #\?)))
(defun rest-varp (x)
	"Returns whether x is a rest varaible (symbol of form ?x..)"
	(if (variablep x)
		(let ((var (symbol-name x)))
			(equal (subseq var (- (length var) 2)) ".."))))
(defun commutativep (op)
	"Returns whether or not an operation is commutative"
	(member op '(and or equiv)))
(defun unaryp (op)
	"Returns whether or not an operation is unary"
	(member op '(not)))
(defun logicalp (expr)
	"Returns whether or not expr is t (true) or f (false)"
	(member expr '(t f)))
(defun get-op (expr)
	"Returns the operation in an expression"
	(car expr))
(defun get-operands (expr)
	"Returns list of operands in an expression"
	(cdr expr))
(defun consistent-bindingsp (bindings)
	"Returns whether or not a list of bindings is valid (does not contain (T . T))"
	(not (member '(t . t) bindings :test #'equalp)))
(defun eq-expr (f g)
	"Returns whether f or g represent the same expression"
	(equalp f g))
(defun variable-match (variable input bindings)
	"Returns the associated value of the variable or (T . T) if it would be associated with two values"
	(cond 	((assoc variable bindings) (if (eq-expr (cdr (assoc variable bindings)) input) (assoc variable bindings) '(t . t)))
			(t (cons variable input))))
(defun null-binding (bindings)
	"Converts nil to (T . T)"
	(if (null bindings) '((t . t)) bindings))
(defun pat-match (pattern input &optional (bindings nil))
	"Returns a(n) (list of) association list(s) of variable bindings"
	(cond	((consp (caar bindings)) (null-binding (remove-if-not #'consistent-bindingsp (mapcar #'(lambda (b) (pat-match pattern input b)) bindings))))
			((not (consistent-bindingsp bindings)) '((t . t)))
			((equalp '(?..) pattern) bindings)
			((and (null input) (null pattern)) bindings)
			((eq-expr pattern input) bindings)
			((and (= (length pattern) 1) (rest-varp (car pattern))) (union bindings (when input `((,(car pattern) . ,input))) :test #'eq-expr))
			((not (consp input)) '((t . t)))
			((equalp '?.. (car pattern))
				(null-binding (remove-if-not #'consistent-bindingsp 
					(loop for i from (length input) downto 0 collect
						(union bindings (pat-match (cdr pattern) (slice input i) bindings))))))
			((rest-varp (car pattern))
				(null-binding (remove-if-not #'consistent-bindingsp 
					(loop for i from (length input) downto 0 collect
						(myunion bindings 
							(pat-match (cdr pattern) (slice input i) bindings) 
							(when (> i 0) (list (variable-match (car pattern) (slice input 0 i) bindings))))))))
			((variablep (car pattern)) (pat-match (cdr pattern) (cdr input) (union bindings (list (variable-match (car pattern) (car input) bindings)) :test #'eq-expr)))
			((and (consp (car pattern)) (consp (car input))) (pat-match (cdr pattern) (cdr input) (pat-match (car pattern) (car input) bindings)))
			(t (if (eq-expr (car pattern) (car input)) (pat-match (cdr pattern) (cdr input) bindings) '((t . t))))))
(defun strip (lst)
	(cond	((or (not (consp lst)) (not (consp (car lst))) (not (consp (caar lst)))) lst)
			((= (length lst) 1) (strip (car lst)))
			(t (apply #'myunion lst))))
(defun pick-bindings (bindings)
	"Randomly selects variable bindings from a list of variable bindings"
	(if (consp (caar bindings)) (elt bindings (random (length bindings))) bindings))
(defun matches (pattern input &optional (bindings nil))
	"Returns whether or not input matches pattern"
	(consistent-bindingsp (pick-bindings (pat-match pattern input bindings))))
(defun evaluate-helper (f)
	"Evaluates all logical computations in an expression"
	(if (consp f)
		(cond	((and (unaryp (car f)) (logicalp (evaluate-helper (cadr f)))) (eval (list (get-op f) (sublis '((f . nil)) (evaluate-helper (cadr f))))))
				((unaryp (car f)) (list (car f) (evaluate-helper (cadr f))))
				((all-of #'logicalp (get-operands f)) (eval (list* (get-op f) (sublis '((f . nil)) (get-operands f)))))
				((all-of #'logicalp (get-operands f) :key #'evaluate-helper) (eval (list* (get-op f) (sublis '((f . nil)) (mapcar #'evaluate-helper (get-operands f))))))
				(t (list* (get-op f) (mapcar #'evaluate-helper (get-operands f)))))
		f))
(defun fix (tree)
	"Fixes bug caused by evaluate"
	(cond	((and (consp tree) (not (listp (cdr tree)))) (cons (fix (car tree)) nil))
			((consp tree) (cons (fix (car tree)) (fix (cdr tree))))
			(t tree)))
(defun evaluate (expression &optional (bindings nil))
	(fix (sublis '((nil . f)) (evaluate-helper (sublis bindings expression)))))
(defun simplify-helper (expr rules)
	"Simplifies an expression, treating it as one unit"
	(when (consp expr)
		(loop for rule in rules do
			(let ((bindings (pat-match (car rule) expr)))
				(when (consistent-bindingsp bindings)
					(return-from simplify-helper (sublis bindings (caddr rule) :test #'eq-expr))))))
	(let ((bindings (pick-bindings (strip (pat-match '(and ?a.. t ?b..) expr)))))
		(when (consistent-bindingsp bindings)
			(return-from simplify-helper (list* 'and (bind bindings '(?a.. ?b..))))))
	(let ((bindings (pick-bindings (strip (pat-match '(or ?a.. f ?b..) expr)))))
		(when (consistent-bindingsp bindings)
			(return-from simplify-helper (list* 'or (bind bindings '(?a.. ?b..))))))
	expr)
(defparameter *simplification-rules* '(	((and ?.. f ?..) -> f)
										((and ?.. ?x ?.. (not ?x) ?..) -> f)
										((and ?.. (not ?x) ?.. ?x ?..) -> f)
										((and ?x) -> ?x)
										((or ?.. t ?..) -> t)
										((or ?x) -> ?x)
										((or ?.. ?x ?.. (not ?x) ?..) -> t)
										((or ?.. (not ?x) ?.. ?x ?..) -> t)
										((not (not ?x)) -> ?x)
										))
(defun simplify (expression &optional (rules *simplification-rules*) (prev-expr expression))
	"Simplifies an expression"
	(if (consp expression)
		(let ((f (simplify-helper (evaluate (loop for term in expression collect (simplify term rules))) rules)))
			(if (eq-expr prev-expr f) f (simplify f rules)))
		expression))
(defun bind (bindings vars)
	(apply #'append (remove-if #'variablep (sublis bindings vars))))
(defun to-or (statement)
	(cond	((matches '(or ?..) statement) statement)
			(t `(or ,statement f))))
(defun resolve (expr1 expr2)
	(when (matches '(and ?..) expr1)
		(loop for wff in (get-operands expr1) when (resolve wff expr2) do (return-from resolve (resolve wff expr2))))
	(when (matches '(and ?..) expr2)
		(loop for wff in (get-operands expr2) when (resolve expr1 wff) do (return-from resolve (resolve expr1 wff))))
	(let ((bindings (pick-bindings (strip (pat-match '(and (or ?a.. ?x ?b..) (or ?c.. (not ?x) ?d..)) `(and ,(to-or expr1) ,(to-or expr2)))))))
		(when (consistent-bindingsp bindings)
			(return-from resolve (list* 'or (bind bindings '(?a.. ?b.. ?c.. ?d..))))))
	(let ((bindings (pick-bindings (strip (pat-match '(and (or ?a.. (not ?x) ?b..) (or ?c.. ?x ?d..)) `(and ,(to-or expr1) ,(to-or expr2)))))))
		(when (consistent-bindingsp bindings)
			(return-from resolve (list* 'or (bind bindings '(?a.. ?b.. ?c.. ?d..))))))
	)
(defun split-and (wff)
	(if (matches '(and ?..) wff) (mappend #'split-and (cdr wff)) (list wff)))
(defun prove-helper (conclusion given)
	(refute (append (mappend #'(lambda (f) (mapcar #'(lambda (c) (list c 'g)) (split-and (->cnf f)))) given) (list (list (->cnf `(not ,conclusion)) 'n)))))
(defun refute (statements &optional (res (caar (last statements))))
	(if (member 'f statements :test #'equal :key #'car) 
		(append statements (list 'qed))
		(progn
			(loop for s in statements for i from 1 do
				(let ((r (simplify (resolve res (car s)))))
					(when (and r (not (member r statements :key #'car :test #'equal)))
						(let ((proof (refute (append statements (list (list r i))) r)))
							(when (eq (car (last proof)) 'QED)
								(return-from refute proof))))))
			(append statements (list '?)))))
			
(defun print-wff (wff &optional (grp nil))
	(cond	((matches '(or ?x) wff) (print-wff (cadr wff) grp))
			((matches '(and ?x) wff) (print-wff (cadr wff) grp))
			((matches '(not ?x) wff) (concatenate 'string "~" (print-wff (cadr wff))))
			((matches '(or ?..) wff) (concatenate 'string (when (eq grp 'and) "(") (print-wff (cadr wff) 'or) " || " (print-wff (list* 'or (cddr wff)) 'or) (when (eq grp 'and) ")")))
			((matches '(and ?..) wff) (concatenate 'string (when (eq grp 'or) "(") (print-wff (cadr wff) 'and) " && " (print-wff (list* 'and (cddr wff)) 'and) (when (eq grp 'or) ")")))
			(t (write-to-string wff))))
(defun prove (conclusion &rest given)
	(let ((proof (prove-helper conclusion given)))
		(if (eq (car (last proof)) '?)
			(princ "Conclusion unable to be proven from premises")
			(loop for wff in (slice proof 0 -1) for i from 1 do
				(cond	((eq (car (last wff)) 'g) (format t "~a. ~a~20t given" i (print-wff (car wff))))
						((eq (car (last wff)) 'n) (format t "~a. ~a~20t negation of conclusion" i (print-wff (car wff))))
						(t (format t "~a. ~a~20t resolve ~a ~a" i (print-wff (car wff)) (1- i) (car (last wff)))))
				(princ #\newline)))
		(car (last proof))))
		
(defun ->cnf-helper (expression)
	(let ((wff (simplify expression)) (tmp nil))
		(cond	((matches '(not (and ?..)) wff) (list* 'or (mapcar #'(lambda (w) (list 'not w)) (cdadr wff))))
				((matches '(not (or ?..)) wff) (list* 'and (mapcar #'(lambda (w) (list 'not w)) (cdadr wff))))
				((matches '(implies ?a ?b) wff) `(or (not ,(cadr wff)) ,(caddr wff)))
				((matches '(equiv ?a ?b) wff) `(and (implies ,(cadr wff) ,(caddr wff)) (implies ,(caddr wff) ,(cadr wff))))
				((consistent-bindingsp (setf tmp (pick-bindings (strip (pat-match '(or ?a.. (or ?b..) ?c..) wff)))))
					(list* 'or (bind tmp '(?a.. ?b.. ?c..))))
				((consistent-bindingsp (setf tmp (pick-bindings (strip (pat-match '(and ?a.. (and ?b..) ?c..) wff)))))
					(list* 'and (bind tmp '(?a.. ?b.. ?c..))))
				((consistent-bindingsp (setf tmp (pick-bindings (strip (pat-match '(or ?a.. (and ?b..) ?c..) wff)))))
					(list* 'and (mapcar #'(lambda (w) (list* 'or w (bind tmp '(?a.. ?c..)))) (sublis tmp '?b..)))) 
				(t wff))))
(defun ->cnf (expression)
	(if (consp expression)
		(let ((wff (->cnf-helper (loop for w in expression collect (->cnf w)))))
			(if (eq-expr wff expression) wff (->cnf wff)))
		expression))