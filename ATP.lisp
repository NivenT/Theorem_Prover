(load "pat-match.lisp")
(defun implies (a b)
	(or (not a) b))
(defun xor (a b)
	(or (and a (not b)) (and b (not a))))
(defun equiv (a b)
	(or (and a b) (and (not a) (not b))))
(defun opp (op)
	(member op '(and or equiv implies xor not)))
(defun commutativep (op)
	"Returns whether or not an operation is commutative"
	(member op '(and or equiv)))
(defun unaryp (op)
	"Returns whether or not an operation is unary"
	(member op '(not)))
(defun logicalp (expr)
	"Returns whether or not expr is t (true) or f (false)"
	(member expr '(t f nil)))
(defun evaluate-helper (f)
	"Evaluates all logical computations in an expression"
	(if (consp f)
		(let ((operands (mapcar #'evaluate-helper (cdr f))) (op (car f)))
			(if (every #'logicalp operands)
				(eval (list* op (sublis '((f . nil)) operands))) (cons op operands)))
		f))
(defun fix (tree)
	"Fixes bug caused by evaluate"
	(cond	((and (consp tree) (not (listp (cdr tree)))) (cons (fix (car tree)) nil))
			((consp tree) (cons (fix (car tree)) (fix (cdr tree))))
			(t tree)))
(defun evaluate (expression &optional (bindings nil))
	(fix (sublis '((nil . f)) (evaluate-helper (sublis bindings expression)))))
(defun compose (f g)
	(lambda (&rest args) (funcall f (apply g args))))
(defparameter *simplification-rules* '(	((and ?a* ?x ?b* ?x ?c*) -> (and ?x ?a* ?b* ?c*))
										((and ?a* f ?b*) -> f)
										((and ?x) -> ?x)
										((and) -> t)
										((or) -> f)
										((or ?a* t ?b*) -> t)
										((or ?x) -> ?x)
										((or ?a* ?x ?b* ?x ?c*) -> (or ?x ?a* ?b* ?c*))
										))
(defun simplify (expr)
	(transform expr *simplification-rules* :rewrite (compose #'evaluate #'absorb-args)))
(defun to-or (statement)
	(cond	((pat-match '(or ?*) statement) statement)
			(t `(or ,statement f))))
(defun absorb-args (x)
	"Reformats expressions containing lists of args (Ex. (and (t f t) f) -> (and t f t f))"
	(if (and (consp x) (opp (car x)))
		(cons (car x) (loop for arg in (cdr x) append
			(let ((arg (absorb-args arg)))
				(if (and (listp arg) (not (opp (car arg))))
					arg (list arg)))))
		x))
(defparameter *resolution-rules* '(	((and (or ?a* ?x ?b*) (or ?c* (not ?x) ?d*)) -> (or ?a* ?b* ?c* ?d*))
									((and (or ?a* (not ?x) ?b*) (or ?c* ?x ?d*)) -> (or ?a* ?b* ?c* ?d*))
									((and (or ?x ?b*) (or ?c* (not ?x) ?d*)) -> (or ?b* ?c* ?d*))
									((and (or (not ?x) ?b*) (or ?c* ?x ?d*)) -> (or ?b* ?c* ?d*))
									))
(defun resolve (expr1 expr2)
	(when (pat-match '(and ?*) expr1)
		(loop for wff in (cdr expr1) when (resolve wff expr2) do (return-from resolve (resolve wff expr2))))
	(when (pat-match '(and ?*) expr2)
		(loop for wff in (cdr expr2) when (resolve expr1 wff) do (return-from resolve (resolve expr1 wff))))
	(let ((res (transform `(and ,(to-or expr1) ,(to-or expr2)) *resolution-rules* :rewrite #'absorb-args)))
		(unless (equalp res `(and ,(to-or expr1) ,(to-or expr2))) res))
	)
(defun split-and (wff)
	(if (pat-match '(and ?*) wff) (mapcan #'split-and (cdr wff)) (list wff)))
(defun prove-helper (conclusion given)
	(refute (append (mapcan #'(lambda (f) (mapcar #'(lambda (c) (list c 'g)) (split-and (->cnf f)))) given) (mapcar #'(lambda (f) (list f 'n)) (split-and (->cnf `(not ,conclusion)))))))
(defun refute (statements &optional (res (caar (last statements))) (line (length statements)))
	;(print statements)
	(if (member 'f statements :test #'equal :key #'car) 
		(append statements (list 'qed))
		(progn
			(loop for s in statements for i from 1 do
				(let ((r (simplify (resolve res (car s)))))
					(when (and r (not (member r statements :key #'car :test #'equal)))
						(let ((proof (refute (append statements (list (list r line i))) r)))
							(when (eq (car (last proof)) 'QED)
								(return-from refute proof))))))
			(loop for s in statements for i from 1 do
				(when (and (eq (cadr s) 'n) (not (equal (car s) res)))
					(let ((proof (refute statements (car s) i)))
						(when (eq (car (last proof)) 'QED)
							(return-from refute proof)))))
			(append statements (list '?)))))
			
(defun print-wff (wff &optional (grp nil))
	(cond	((pat-match '(or ?x) wff) (print-wff (cadr wff) grp))
			((pat-match '(and ?x) wff) (print-wff (cadr wff) grp))
			((pat-match '(not ?x) wff) (concatenate 'string "~" (print-wff (cadr wff))))
			((pat-match '(or ?*) wff) (concatenate 'string 
				(unless (member grp '(nil or)) "(") (print-wff (cadr wff) 'or) " || " (print-wff (list* 'or (cddr wff)) 'or) (unless (member grp '(nil or)) ")")))
			((pat-match '(and ?*) wff) (concatenate 'string 
				(unless (member grp '(nil and)) "(") (print-wff (cadr wff) 'and) " && " (print-wff (list* 'and (cddr wff)) 'and) (unless (member grp '(nil and)) ")")))
			((pat-match '(implies ?a ?b) wff) (concatenate 'string 
				(when (eq grp 'im) "(") (print-wff (cadr wff) 'im) " -> " (print-wff (caddr wff) 'im) (when (eq grp 'im) ")")))
			((pat-match '(equiv ?a ?b) wff) (concatenate 'string 
				(when (eq grp 'im) "(") (print-wff (cadr wff) 'im) " <-> " (print-wff (caddr wff) 'im) (when (eq grp 'im) ")")))
			(t (write-to-string wff))))
(defun prove (conclusion &rest given)
	(let ((proof (prove-helper conclusion given)))
		(if (eq (car (last proof)) '?)
			(princ "Conclusion unable to be proven from premises")
			(loop for wff in (slice proof 0 -1) for i from 1 do
				(cond	((eq (car (last wff)) 'g) (format t "~a. ~a~20t given" i (print-wff (car wff))))
						((eq (car (last wff)) 'n) (format t "~a. ~a~20t negation of conclusion" i (print-wff (car wff))))
						(t (format t "~a. ~a~20t resolve ~a ~a" i (print-wff (car wff)) (car (last wff 2)) (car (last wff)))))
				(princ #\newline)))
		(car (last proof))))
(defparameter *->cnf-rules* '(	((not (and ?a ?*)) -> (or (not ?a) (not (and ?*))))
								((not (or ?a ?*)) -> (and (not ?a) (not (or ?*))))
								((implies ?a ?b) -> (or (not ?a) ?b))
								((equiv ?a ?b) -> (and (implies ?a ?b) (implies ?b ?a)))
								((xor ?a ?b) -> (and (or ?a ?b) (or (not ?a) (not ?b))))
								((or ?a* (or ?b*) ?c*) -> (or ?a* ?b* ?c*))
								((and ?a* (and ?b*) ?c*) -> (and ?a* ?b* ?c*))
								))
(defun ->cnf (expr)
	"Converts logical expression to conjunctive normal form"
	(transform expr (append *->cnf-rules* *simplification-rules*) :rewrite #'absorb-args))
(defun get-vars (wff)
	(cond 	((member wff '(t f implies not and or xor equiv)) nil)
			((null wff) nil)
			((symbolp wff) (list wff))
			((consp wff) (union (get-vars (car wff)) (get-vars (cdr wff))))
			(t nil)))
(defun num->logbindings (n)
	(if (= n 0) nil (append (num->logbindings (ash n -1)) (list (logand n 1)))))
(defun make-bindings (vars vals)
	(loop for v in vars for w in vals collect (cons v w)))
(defun make-truth-table (wff)
	(let ((vars (get-vars wff)))
		(format t "  ~a  ~{|  ~a  ~}|  ~a~%" (car vars) (cdr vars) (print-wff wff))
		(loop for v from 1 to (1+ (length vars)) do (format t "------"))
		(flet ((->log bit (if (= bit 0) 'f 't)))
			(loop for i from 0 to (1- (expt 2 (length vars))) do
				(let* ((tmp (num->logbindings i)) (vals (sublis '((1 . t) (0 . f)) (append (make-list (- (length vars) (length tmp)) :initial-element 0) tmp))))
					(format t "~%  ~a  ~{|  ~a  ~}|  ~a" (car vals) (cdr vals) (evaluate wff (make-bindings vars vals))))))))